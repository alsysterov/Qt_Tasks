/* Класс Graph для функций поиска в ширину
 */

#ifndef BFS_H
#define BFS_H

#include <map>
#include <list>
#include <queue>

using namespace std;

class Graph
{
    // Контейнер Map для построения графа и выполнения операций с ним.

    map<int, list<int>> edges;

public:

    // Функция добавления двусторонних рёбер.

    void AddEdge(int e1, int e2)
    {
        edges[e1].push_back(e2);
        edges[e2].push_back(e1);
    }

    // Функция очистки (инициализации) графа

    void ClearMap()
    {
        edges.clear();
    }

    // Поиск в ширину, возвращающий список полного найденного пути в случае его наличия
    // и список {-1,-1} в случае его отсутствия.
    // Принимает аргументы в виде целочисленных значений начальной и конечной точки,
    // а также размера массива, используемого для запоминания предшествующей точки.

    list<int> BFS(int start, int finish, int size)
    {
        // Контейнер для хранения статуса "посещённости" вершин графа

        map<int, int> visited;

        // Очередь queue для временного хранения непосещённых точек

        queue<int> qint;

        // Конечный список пути, возвращаемый функцией в случае его наличия

        list<int> path;

        // Массив предшествующих точек (точка, предшествующая точке, записанной в индексе,
        // записывается в значение)

        int prev[size];

        // Целое число для последующей итерации для записи точек в итоговый список

        int i = finish;

        // Контроль правильности ввода значений начальной и конечной точек

        if(start < 0 || finish < 0)
            return {-1,-1};

        // Инициализация массива предшествующих точек

        for (int j = 0; j < size; j++)
            prev[j] = -2;

        // Запись начальной точки в очередь и отметка её посещённости

        qint.push(start);
        visited[start] = true;

        // Задание несуществующей точки, предшествующей начальной

        prev[start] = -3;

        // Основной цикл поиска с возвращением {-1,-1} в случае
        // отсутствия его досрочного завершения

        while (!qint.empty())
        {
            // Переменная для временной записи рассматриваемой точки

            int node = qint.front();

            // Удаление рассматриваемой точки из очереди

            qint.pop();

            // Цикл для всех точек, прилегающих к рассматриваемой

            for (int next : edges[node])
            {
                // Условие, отсеивающее непосещённые, меньшие чем 0 и равные
                // по значению рассматриваемой точке

                if (!visited[next] && next != node && next >= 0)
                {
                    // Добавление следующей точки в очередь, отметка о её
                    // посещённости и запись предшествующей для неё точки в
                    // соответствующий массив

                    qint.push(next);
                    visited[next] = true;
                    prev[next] = node;

                    // Условие наличия пути (следующая точка равна конечной)

                    if (next == finish)
                    {
                        // Добавление конечной точки в итоговый список

                        path.push_front(finish);

                        // Нахождение пути от конца до начала, используя
                        // массив предшествующих точек

                        while (i != start)
                        {
                            path.push_front(prev[i]);
                            i = prev[i];
                        }
                        return path;
                    }
                }
            }
        }
        return {-1, -1};
    }
};
#endif // BFS_H
